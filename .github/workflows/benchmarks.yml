name: P-ATA Benchmarks

on:
  push:
    paths:
      - 'p-ata/**'
      - 'program/**'
      - '.github/workflows/benchmarks.yml'
    branches: [main, p-ata, p-ata-dev]
  pull_request:
    paths:
      - 'p-ata/**'
      - 'program/**'
      - '.github/workflows/benchmarks.yml'
    branches: [main, p-ata]
  workflow_dispatch:
    inputs:
      clear_cache:
        description: 'Clear build cache before running'
        type: boolean
        default: false

env:
  RUST_BACKTRACE: 1

jobs:
  run_benchmarks:
    name: Run P-ATA Benchmarks
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    steps:
      - name: Git Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          submodules: recursive

      - name: Setup Environment
        uses: ./.github/actions/setup
        with:
          cargo-cache-key: cargo-benchmarks
          solana: true

      - name: Generate Build Cache Keys
        id: build-cache-keys
        run: |
          # Generate separate cache keys for each program
          original_ata_key=$(find program -name "*.rs" -o -name "Cargo.toml" -o -name "Cargo.lock" -o -name "build.rs" | \
                            xargs sha256sum | sha256sum | cut -d' ' -f1)
          p_ata_key=$(find p-ata -name "*.rs" -o -name "Cargo.toml" -o -name "Cargo.lock" -o -name "build.rs" | \
                     xargs sha256sum | sha256sum | cut -d' ' -f1)
          
          echo "original-ata-key=original-ata-$original_ata_key" >> $GITHUB_OUTPUT
          echo "p-ata-key=p-ata-$p_ata_key" >> $GITHUB_OUTPUT
          
          echo "🔑 Original ATA cache key: original-ata-$original_ata_key"
          echo "🔑 P-ATA cache key: p-ata-$p_ata_key"

      - name: Cache Original ATA Program
        id: cache-original-ata
        uses: actions/cache@v4
        if: ${{ !github.event.inputs.clear_cache }}
        with:
          path: program/target/deploy/
          key: ${{ steps.build-cache-keys.outputs.original-ata-key }}
          restore-keys: |
            original-ata-

      - name: Cache P-ATA Program
        id: cache-p-ata
        uses: actions/cache@v4
        if: ${{ !github.event.inputs.clear_cache }}
        with:
          path: |
            p-ata/target/deploy/
            p-ata/programs/
          key: ${{ steps.build-cache-keys.outputs.p-ata-key }}
          restore-keys: |
            p-ata-

      - name: Clear Cache (Manual)
        if: ${{ github.event.inputs.clear_cache }}
        run: |
          echo "🧹 Manual cache clear requested - forcing rebuild"
          rm -rf program/target/deploy/ p-ata/target/deploy/ p-ata/programs/ 2>/dev/null || true

      - name: Build Original ATA Program
        if: steps.cache-original-ata.outputs.cache-hit != 'true' || github.event.inputs.clear_cache
        run: |
          echo "🔨 Building Original ATA program (cache miss)..."
          cd program
          cargo build-sbf
          cd ..
          echo "✅ Original ATA program built successfully"

      - name: Build P-ATA Program
        if: steps.cache-p-ata.outputs.cache-hit != 'true' || github.event.inputs.clear_cache
        run: |
          echo "🔨 Building P-ATA program (cache miss)..."
          cd p-ata
          cargo build-sbf --features build-programs
          cd ..
          echo "✅ P-ATA program built successfully"

      - name: Verify Cached Programs
        run: |
          echo "📋 Program build summary:"
          
          # Check Original ATA
          if [ "${{ steps.cache-original-ata.outputs.cache-hit }}" == "true" ]; then
            echo "  💾 Original ATA: Restored from cache"
          else
            echo "  🔨 Original ATA: Built from source"
          fi
          
          # Check P-ATA
          if [ "${{ steps.cache-p-ata.outputs.cache-hit }}" == "true" ]; then
            echo "  💾 P-ATA: Restored from cache"
          else
            echo "  🔨 P-ATA: Built from source"
          fi
          
          echo ""
          echo "📁 Available program binaries:"
          find program p-ata -name "*.so" -type f | while read file; do
            echo "  ✅ $file ($(stat -c%s "$file") bytes)"
          done
          
          echo ""
          echo "🔑 Available keypairs:"
          find program p-ata -name "*-keypair.json" -type f | while read file; do
            echo "  🔑 $file"
          done
          
          echo ""
          echo "✅ Program verification completed"

      - name: Run Benchmarks
        run: |
          cd p-ata
          
          # Create output directory
          mkdir -p benchmark_results
          
          # Run comparison benchmarks and capture output while showing it
          echo "🚀 Running P-ATA vs Original ATA Comparison Benchmarks"
          cargo bench --features build-programs ata_instruction_benches 2>&1 | tee benchmark_results/comparison.log
          
          # Run failure scenarios
          echo "🧪 Running Failure Scenario Tests"  
          cargo bench --features build-programs failure_scenarios 2>&1 | tee benchmark_results/failures.log
          
          cd ..

      - name: Generate Badge Data
        run: |
          cd p-ata
          
          # Install jq for JSON processing
          sudo apt-get update && sudo apt-get install -y jq bc
          
          # Generate badges from existing benchmark results
          source scripts/run_local_benchmarks.sh
          generate_badges_only

      - name: Update README with Results
        if: github.ref == 'refs/heads/main'
        run: |
          cd p-ata
          
          # Configure git
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"
          
          # Check if README.md was updated
          if git diff --quiet README.md; then
            echo "No changes to README.md"
          else
            echo "README.md updated with new badges"
            git add README.md
            git commit -m "Update README with benchmark badges - $(date -u '+%Y-%m-%d %H:%M:%S UTC')"
            git push origin HEAD
          fi 