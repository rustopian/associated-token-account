use {
    crate::entrypoint::process_instruction as pinocchio_process_instruction,
    alloc::collections::BTreeMap,
    bincode,
    core::cell::RefCell,
    mollusk_svm::{program::loader_keys, Mollusk},
    solana_program::{account_info::AccountInfo, msg, program_error::ProgramError, pubkey::Pubkey},
    solana_program_test::{ProgramTest, *},
    solana_sdk::{
        account::Account,
        hash::Hash,
        instruction::InstructionError,
        signature::Keypair,
        signer::Signer,
        transaction::{Transaction, TransactionError},
    },
    spl_associated_token_account, spl_associated_token_account_client,
    spl_token_2022::extension::ExtensionType,
};

fn process_instruction(
    program_id: &Pubkey,
    accounts: &[AccountInfo],
    instruction_data: &[u8],
) -> Result<(), ProgramError> {
    msg!("ðŸ”¥ WRAPPER CALLED!");

    // This wrapper allows us to test SPL ATA instructions against our p-ata implementation
    // We register our p-ata program with the SPL ATA program ID to intercept SPL ATA calls

    // Convert program_id to pinocchio format
    let pinocchio_program_id = pinocchio::pubkey::Pubkey::from(program_id.to_bytes());

    // Call the pinocchio process_instruction with simple transmute (layouts are identical)
    msg!("ðŸ”¥ CALLING PINOCCHIO!");
    msg!("ðŸ”¥ DEBUG: About to transmute accounts");
    let pinocchio_accounts: &[pinocchio::account_info::AccountInfo] =
        unsafe { core::mem::transmute(accounts) };
    msg!("ðŸ”¥ DEBUG: Transmute successful, about to call pinocchio entrypoint");

    match pinocchio_process_instruction(&pinocchio_program_id, pinocchio_accounts, instruction_data)
    {
        Ok(()) => Ok(()),
        Err(pinocchio::program_error::ProgramError::NotEnoughAccountKeys) => {
            Err(ProgramError::NotEnoughAccountKeys)
        }
        Err(pinocchio::program_error::ProgramError::InvalidAccountData) => {
            Err(ProgramError::InvalidAccountData)
        }
        Err(pinocchio::program_error::ProgramError::InvalidArgument) => {
            Err(ProgramError::InvalidArgument)
        }
        Err(pinocchio::program_error::ProgramError::InvalidInstructionData) => {
            Err(ProgramError::InvalidInstructionData)
        }
        Err(_) => Err(ProgramError::Custom(1)),
    }
}

fn id() -> Pubkey {
    // Use the actual SPL ATA program ID so our program intercepts those calls
    spl_associated_token_account::id()
}

#[allow(dead_code)]
pub fn program_test(token_mint_address: Pubkey) -> ProgramTest {
    let mut pc = ProgramTest::new(
        "spl_associated_token_account",
        id(),
        processor!(process_instruction),
    );

    // Add a token mint account
    //
    // The account data was generated by running:
    //      $ solana account EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v \
    //                       --output-file src/tests/fixtures/token-mint-data.bin
    //
    pc.add_account_with_file_data(
        token_mint_address,
        1461600,
        spl_token::id(),
        "src/tests/fixtures/token-mint-data.bin",
    );

    // Dial down the BPF compute budget to detect if the program gets bloated in the
    // future
    pc.set_compute_max_units(60_000);

    pc
}

// ================= MOLLUSK-BASED TEST RUNNERS =================

/// Mollusk-based banks client that matches the original API
pub struct MolluskBanksClient {
    pub mollusk: Mollusk,
    pub accounts: RefCell<BTreeMap<Pubkey, Account>>,
}

impl MolluskBanksClient {
    pub async fn get_rent(
        &self,
    ) -> Result<solana_program::sysvar::rent::Rent, solana_program::program_error::ProgramError>
    {
        Ok(self.mollusk.sysvars.rent.clone())
    }

    pub async fn process_transaction(
        &self,
        transaction: Transaction,
    ) -> Result<(), BanksClientError> {
        // Process each instruction in the transaction through Mollusk
        for instruction in &transaction.message.instructions {
            let program_id =
                transaction.message.account_keys[instruction.program_id_index as usize];

            // Build the instruction with proper accounts
            let mut instruction_accounts = alloc::vec::Vec::new();
            for &account_index in &instruction.accounts {
                let account_key = transaction.message.account_keys[account_index as usize];
                let account = self
                    .accounts
                    .borrow()
                    .get(&account_key)
                    .cloned()
                    .unwrap_or_else(|| {
                        // Create a default account if it doesn't exist
                        Account::new(0, 0, &solana_sdk::system_program::id())
                    });
                instruction_accounts.push((account_key, account));
            }

            // Create the instruction for Mollusk with proper account meta flags
            let mut mollusk_accounts = alloc::vec::Vec::new();
            for &account_index in &instruction.accounts {
                let account_key = transaction.message.account_keys[account_index as usize];

                // Determine if this account is a signer
                let is_signer = if (account_index as usize)
                    < transaction.message.header.num_required_signatures as usize
                {
                    true
                } else {
                    false
                };

                // Determine if this account is writable
                let is_writable = if (account_index as usize)
                    < (transaction.message.header.num_required_signatures as usize
                        - transaction.message.header.num_readonly_signed_accounts as usize)
                {
                    true // Writable signer
                } else if (account_index as usize)
                    >= transaction.message.header.num_required_signatures as usize
                    && (account_index as usize)
                        < (transaction.message.account_keys.len()
                            - transaction.message.header.num_readonly_unsigned_accounts as usize)
                {
                    true // Writable non-signer
                } else {
                    false // Read-only
                };

                if is_writable {
                    mollusk_accounts.push(solana_sdk::instruction::AccountMeta::new(
                        account_key,
                        is_signer,
                    ));
                } else {
                    mollusk_accounts.push(solana_sdk::instruction::AccountMeta::new_readonly(
                        account_key,
                        is_signer,
                    ));
                }
            }

            let mollusk_instruction = solana_sdk::instruction::Instruction {
                program_id,
                accounts: mollusk_accounts,
                data: instruction.data.clone(),
            };

            // Process the instruction through Mollusk
            let result = self
                .mollusk
                .process_instruction(&mollusk_instruction, &instruction_accounts);

            // Update our account tracking with the results
            for (pubkey, account) in result.resulting_accounts {
                self.accounts.borrow_mut().insert(pubkey, account);
            }

            // Check if the instruction failed
            match result.program_result {
                mollusk_svm::result::ProgramResult::Success => {}
                mollusk_svm::result::ProgramResult::Failure(err) => {
                    // Convert ProgramError to InstructionError with custom mapping
                    let instruction_error =
                        map_mollusk_error_to_original(&mollusk_instruction, err);
                    return Err(BanksClientError::TransactionError(
                        TransactionError::InstructionError(0, instruction_error),
                    ));
                }
                mollusk_svm::result::ProgramResult::UnknownError(_) => {
                    return Err(BanksClientError::TransactionError(
                        TransactionError::InstructionError(
                            0,
                            InstructionError::ProgramFailedToComplete,
                        ),
                    ));
                }
            }
        }

        Ok(())
    }

    pub async fn get_account(
        &self,
        pubkey: Pubkey,
    ) -> Result<Option<Account>, solana_program::program_error::ProgramError> {
        // Return the account if it exists in our tracking
        Ok(self.accounts.borrow().get(&pubkey).cloned())
    }

    pub async fn get_new_latest_blockhash(
        &self,
        _previous_blockhash: &Hash,
    ) -> Result<Hash, solana_program::program_error::ProgramError> {
        // Return a new mock blockhash
        Ok(Hash::new_unique())
    }
}

/// Mollusk-based program test that matches the original API
pub struct MolluskProgramTest {
    mollusk: Mollusk,
    token_mint_address: Pubkey,
    accounts: BTreeMap<Pubkey, Account>,
}

impl MolluskProgramTest {
    pub fn add_account(&mut self, pubkey: Pubkey, account: Account) {
        self.accounts.insert(pubkey, account);
    }

    pub async fn start(self) -> (MolluskBanksClient, Keypair, Hash) {
        let payer = Keypair::new();
        let recent_blockhash = Hash::default();

        let mut accounts = self.accounts;

        // Add the payer account
        accounts.insert(
            payer.pubkey(),
            Account::new(1_000_000_000, 0, &solana_sdk::system_program::id()),
        );

        // Add the token mint account with REAL mint data from fixture file
        // (Same approach as the original program_test_2022)
        let mint_data = read_file("src/tests/fixtures/token-mint-data.bin");
        accounts.insert(
            self.token_mint_address,
            Account {
                lamports: 1461600,
                data: mint_data,
                owner: spl_token_2022::id(),
                executable: false,
                rent_epoch: 0,
            },
        );

        // Add system program
        accounts.insert(
            solana_sdk::system_program::id(),
            Account::new(0, 0, &solana_sdk::native_loader::id()),
        );

        // Add token program
        accounts.insert(
            spl_token_2022::id(),
            Account::new(0, 0, &loader_keys::LOADER_V3),
        );

        // Add rent sysvar account so token program can access rent exemption info
        let rent = self.mollusk.sysvars.rent.clone();
        let rent_data = bincode::serialize(&rent).expect("serialize rent");
        accounts.insert(
            solana_program::sysvar::rent::id(),
            Account {
                lamports: 1,
                data: rent_data,
                owner: solana_program::sysvar::id(),
                executable: false,
                rent_epoch: 0,
            },
        );

        let banks_client = MolluskBanksClient {
            mollusk: self.mollusk,
            accounts: RefCell::new(accounts),
        };

        (banks_client, payer, recent_blockhash)
    }
}

/// Mollusk-based equivalent of program_test_2022 - matches original API exactly
pub fn mollusk_program_test_2022(token_mint_address: Pubkey) -> MolluskProgramTest {
    let mut mollusk = Mollusk::default();

    // Add our p-ata program with the SPL ATA program ID (like the original wrapper)
    let program_id = spl_associated_token_account::id();
    mollusk.add_program(
        &program_id,
        "target/deploy/pinocchio_ata_program",
        &loader_keys::LOADER_V3,
    );

    // Add required programs
    mollusk.add_program(
        &spl_token_2022::id(),
        "programs/token-2022/target/deploy/spl_token_2022",
        &loader_keys::LOADER_V3,
    );

    MolluskProgramTest {
        mollusk,
        token_mint_address,
        accounts: BTreeMap::new(),
    }
}

/// Mollusk-based equivalent of program_test - matches original API exactly
pub fn mollusk_program_test(token_mint_address: Pubkey) -> MolluskProgramTest {
    let mut mollusk = Mollusk::default();

    // Add our p-ata program with the SPL ATA program ID (like the original wrapper)
    let program_id = spl_associated_token_account::id();
    mollusk.add_program(
        &program_id,
        "target/deploy/pinocchio_ata_program",
        &loader_keys::LOADER_V3,
    );

    // Add required programs - use regular SPL token for non-2022 tests
    mollusk.add_program(
        &spl_token::id(),
        "programs/token/target/deploy/spl_token",
        &loader_keys::LOADER_V3,
    );

    MolluskProgramTest {
        mollusk,
        token_mint_address,
        accounts: BTreeMap::new(),
    }
}

#[allow(dead_code)]
pub fn program_test_2022(token_mint_address: Pubkey) -> ProgramTest {
    let mut pc = ProgramTest::new(
        "spl_associated_token_account",
        id(),
        processor!(process_instruction),
    );

    // Add a token mint account
    //
    // The account data was generated by running:
    //      $ solana account EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v \
    //                       --output-file src/tests/fixtures/token-mint-data.bin
    //
    pc.add_account_with_file_data(
        token_mint_address,
        1461600,
        spl_token_2022::id(),
        "src/tests/fixtures/token-mint-data.bin",
    );

    // Dial down the BPF compute budget to detect if the program gets bloated in the
    // future
    pc.set_compute_max_units(50_000);

    pc
}

/// Maps Mollusk errors to match the original solana_program_test behavior
fn map_mollusk_error_to_original(
    instruction: &solana_sdk::instruction::Instruction,
    error: ProgramError,
) -> InstructionError {
    // Check if this is an ATA instruction
    if instruction.program_id == spl_associated_token_account::id() {
        match error {
            // System program "account already exists" -> IllegalOwner for non-idempotent ATA create
            ProgramError::Custom(0) => {
                // Check if this is a non-idempotent create operation
                if instruction.data.len() > 0 && instruction.data[0] == 0 {
                    // This is create_associated_token_account (not idempotent)
                    // System program error "account already exists" should become IllegalOwner
                    InstructionError::IllegalOwner
                } else {
                    // Convert normally for other operations
                    InstructionError::from(u64::from(error))
                }
            }
            // P-ATA program "Provided owner is not allowed" -> Custom(0) for InvalidOwner
            ProgramError::IllegalOwner => {
                // This is likely from the p-ata program detecting wrong owner
                // Should be converted to Custom(0) which represents InvalidOwner
                InstructionError::Custom(0)
            }
            // InvalidInstructionData from canonical address mismatch -> InvalidSeeds
            ProgramError::InvalidInstructionData => {
                // This happens when the provided ATA address doesn't match the canonical address
                InstructionError::InvalidSeeds
            }
            // InvalidArgument might be InvalidSeeds if ATA address doesn't match expected seeds
            ProgramError::InvalidArgument => {
                // Check if this is due to invalid ATA address (seeds mismatch)
                if instruction.accounts.len() >= 4 {
                    let provided_ata_address = instruction.accounts[1].pubkey;
                    let wallet_address = instruction.accounts[2].pubkey;
                    let token_mint_address = instruction.accounts[3].pubkey;

                    // Calculate expected ATA address
                    let expected_ata_address = spl_associated_token_account_client::address::get_associated_token_address_with_program_id(
                        &wallet_address,
                        &token_mint_address,
                        &spl_token_2022::id(),
                    );

                    // If addresses don't match, this is an InvalidSeeds error
                    if provided_ata_address != expected_ata_address {
                        InstructionError::InvalidSeeds
                    } else {
                        InstructionError::from(u64::from(error))
                    }
                } else {
                    InstructionError::from(u64::from(error))
                }
            }
            _ => {
                // Convert normally for other errors
                InstructionError::from(u64::from(error))
            }
        }
    } else {
        // Convert normally for non-ATA instructions
        InstructionError::from(u64::from(error))
    }
}
